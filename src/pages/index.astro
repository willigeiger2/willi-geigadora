---
import InteractiveCanvas from '../components/InteractiveCanvas.astro';
import Heading1Card from '../components/Heading1Card.astro';
import NavBar from '../components/NavBar.astro';
import TextCard from '../components/TextCard.astro';
import VideoFill from '../components/VideoFill.astro';
import FullscreenLayout from '../layouts/FullscreenLayout.astro';
import PassiveOverlay from '../layouts/PassiveOverlay.astro';
import Layout from '../layouts/Layout.astro';

const title = "Willi Geiger";
const videoBg = { src: "/images/looping-smoke.mp4", type: "video/mp4" };
const heading = "Lost?";
const text = "\
	I'm Willi Geiger, this is my place to experiment.\
	Right now, you're looking at a particle system.\
	Try interacting with the screen.";
---

<Layout title={title}>
	<main>
		<FullscreenLayout>
			<NavBar></NavBar>
		    <VideoFill
		      	src={videoBg.src}
				type={videoBg.type}
			></VideoFill>
			<PassiveOverlay>
				<Heading1Card text={heading}></Heading1Card>
				<TextCard text={text}></TextCard>
			</PassiveOverlay>
		    <InteractiveCanvas id="canvas"></InteractiveCanvas>
		</FullscreenLayout>
	</main>
</Layout>

<style>
	main {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		width: 100%;
		height: 100%;
		color: white;
		font-size: 20px;
		line-height: 1.6;
	}
</style>

<script>
	import { BrownianField } from "../scripts/BrownianField";
	import { LinearField } from "../scripts/LinearField";
	import { Color, Point, FieldOutput, ParticleSystem }
		from "../scripts/ParticleSystem";
	import { RadialField } from "../scripts/RadialField";
	import * as Utils from "../scripts/utils";
	import { VortexField } from "../scripts/VortexField";
	import { WaveField } from "../scripts/WaveField";

	const canvas = document.querySelector('.interactive-canvas') as HTMLCanvasElement;
	let tPre = performance.now();
	var cxPrev = 0, cyPrev = 0;
	var cursorActive = false;

	let bubbles = new ParticleSystem();
	bubbles.createGrid(50, 50);

	// Designate some of the particles as "spinners," which add velocity
	const numSpinners = 3;
	var spinners: number[] = [];
	var spinnerOmegas: number[] = [];
	for (var n = 0; n < numSpinners; n++) {
		const b = Math.round((bubbles.pos.length - 1) * Math.random());
		spinners.push(b);
		spinnerOmegas.push(2.25 * (Math.random() - 0.5));
	}

	// Explode on touch/button down
	canvas.addEventListener("mousedown", mousedown);
	//canvas.addEventListener("touchstart", touchstart);

	requestAnimationFrame(animate);

	function mousedown(e: MouseEvent) {
		explode(e.clientX / canvas.clientWidth,
			    e.clientY / canvas.clientHeight, 200);
	}

	function touchstart(e: TouchEvent) {
		if (!e.touches[0]) {
			return;
		}
		explode(e.touches[0].clientX / canvas.clientWidth,
			    e.touches[0].clientY / canvas.clientHeight, 10);
	}

	function explode(x: number, y: number, force: number) {
		let radialField = new RadialField(
			new Point(x, y), force,
			new Point(canvas.clientWidth, canvas.clientHeight));
		let radial = radialField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			// Don't factor in dt -- consider this an impulse force
			bubbles.vel[i].x += radial.falloff[i] * radial.field[i].x;
			bubbles.vel[i].y += radial.falloff[i] * radial.field[i].y;
		}
	}

	// Field constants
	const upwardSpeed = -0.15;
	const waveMag = 0.1;
	const waveFreq = 1.25;
	const fluidDrag = 0.35;
	const brownianMagnitude = 0.005;

	let brownianField = new BrownianField(
		new Point(brownianMagnitude, brownianMagnitude));
	let upwardField = new LinearField(new Point(0.0, upwardSpeed));

	function animate(timestamp: number) {
		requestAnimationFrame(animate);
		const dt = Math.min((timestamp - tPre)/1000.0, 1.0/15.0);
		tPre = timestamp;

		//console.log("FPS: " + 1.0 / dt);

		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		canvas.width = w;
		canvas.height = h;

		const c = canvas.getContext('2d');
		if (c == null) {
			return;
		}
		c.strokeStyle = "#0004";
		c.fillStyle = "#0001";
		c.lineWidth = 0.5;

		// Reset acceleration
		for (var i = 0; i < bubbles.pos.length; i++) {
			bubbles.acc[i].x = 0.0;
			bubbles.acc[i].y = 0.0;
		}

		// Apply force fields
		let brownian = brownianField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			// Don't factor in dt -- consider this an impulse force
			bubbles.vel[i].x += brownian.falloff[i] * brownian.field[i].x;
			bubbles.vel[i].y += brownian.falloff[i] * brownian.field[i].y;
		}

		// Apply mouse drag
		let cx = Number.parseFloat(
			canvas.getAttribute("cursorX") || "0");
		let cy = Number.parseFloat(
			canvas.getAttribute("cursorY") || "0");
		let vx = cursorActive ? (cx - cxPrev) / w / dt : 0.0;
		let vy = cursorActive ? (cy - cyPrev) / h / dt : 0.0;
		cxPrev = cx;
		cyPrev = cy;
		cursorActive = (Number.parseInt(canvas.getAttribute(
			"cursorActive") || "0") != 0);
		const Cd = 1.0;
		const falloff = 5.0;
		for (var i = 0; i < bubbles.pos.length; i++) {
			let dx = cx / w - bubbles.pos[i].x;
			let dy = cy / h - bubbles.pos[i].y;
			if (dx >  0.5) dx -= 1.0;
			if (dx < -0.5) dx += 1.0;
			const d = Math.sqrt(dx * dx + dy * dy);
			const k = Math.pow(1.0 - Cd / (falloff * d + 1.0), dt);
			if (Math.abs(vx) > 0.0) {
				bubbles.acc[i].x += (1.0 - k) * (vx - bubbles.vel[i].x) / dt;
			}
			if (Math.abs(vy) > 0.0) {
				bubbles.acc[i].y += (1.0 - k) * (vy - bubbles.vel[i].y) / dt;
			}
		}

		// Fluid drag
		let fluidVel = new Array<Point>(bubbles.pos.length);
		for (var i = 0; i < bubbles.pos.length; i++) {
			fluidVel[i] = new Point(0.0, 0.0);
		}

		// Spinners
		for (var n = 0; n < numSpinners; n++) {
			let vortex: FieldOutput = new VortexField(
					bubbles.pos[spinners[n]],
					spinnerOmegas[n]).evaluate(bubbles.pos);
			for (var i = 0; i < bubbles.pos.length; i++) {
				fluidVel[i].x += vortex.falloff[i] * vortex.field[i].x;
				fluidVel[i].y += vortex.falloff[i] * vortex.field[i].y;
			}
		}

		// Upward motion
		let upward = upwardField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			fluidVel[i].x += upward.falloff[i] * upward.field[i].x;
			fluidVel[i].y += upward.falloff[i] * upward.field[i].y;
		}
		// Horizontal oscillation
		let waveAxis = new Point(0.0, 1.0);
		let waveField = new WaveField(waveAxis, waveMag, waveFreq, 0.0);
		let wave = waveField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			fluidVel[i].x += wave.falloff[i] * wave.field[i].x;
			fluidVel[i].y += wave.falloff[i] * wave.field[i].y;
		}

		// Apply combined fluid drag
		let fd = Math.pow(1.0 - fluidDrag, dt);
		for (var i = 0; i < bubbles.pos.length; i++) {
			bubbles.acc[i].x += (1.0 - fd)
				* (fluidVel[i].x - bubbles.vel[i].x) / dt;
			bubbles.acc[i].y += (1.0 - fd)
				* (fluidVel[i].y - bubbles.vel[i].y) / dt;
		}

		bubbles.advect(dt);

		// Handle edges
		for (var i = 0; i < bubbles.pos.length; i++) {
			// Handle particles going off screen
			while (bubbles.pos[i].x < 0.0) {
				bubbles.pos[i].x += 1.0;
			}
			while (bubbles.pos[i].x > 1.0) {
				bubbles.pos[i].x -= 1.0;
			}
			while (bubbles.pos[i].y < 0.0) {
				bubbles.pos[i].y += 1.0;
			}
			if (bubbles.pos[i].y > 1.03) {
				bubbles.vel[i].y = -0.5 * Math.abs(bubbles.vel[i].y);
			}
		}

		// Set color according to relative velocity
		for (var i = 0; i < bubbles.pos.length; i++) {
			let hx = bubbles.vel[i].x;
			let hy = bubbles.vel[i].y - upwardSpeed;
			let hue = Math.atan2(hy, hx) / (2 * Math.PI) + 0.5;
			let sat = Math.min(0.2 * Math.pow(hx * hx + hy * hy, 0.0), 1.0);
			let val = 1.0;
			let rgb = Utils.hsv2rgb(hue, sat, val);
			let a = 0.75;
			bubbles.rgb[i] = new Color(rgb[0], rgb[1], rgb[2]);
			bubbles.alpha[i] = 0.8;
		}

		// Draw
		const areaScale = 0.001 * Math.sqrt(w * w + h * h);
		const fillDarker = 0.4;
		const fillTrans = 0.25;
		for (var i = 0; i < bubbles.pos.length; i++) {
			let px = bubbles.pos[i].x * w;
			let py = bubbles.pos[i].y * h;
			let rgb = bubbles.rgb[i];
			let alpha = bubbles.alpha[i];

			c.strokeStyle = "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b +
			                    ", " + alpha + ")";
			c.fillStyle = "rgba(" + fillDarker * rgb.r + ", " + fillDarker * rgb.g +
								", " + fillDarker * rgb.b + ", " + fillTrans * alpha + ")";
			c.beginPath();
			c.moveTo(px + areaScale * bubbles.rad[i], py);
			c.arc(px, py, areaScale * bubbles.rad[i], 0, 2.0 * Math.PI, false);
			c.stroke();
			c.fill();
		}
	}
</script>

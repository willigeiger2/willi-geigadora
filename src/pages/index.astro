---
import InteractiveCanvas from '../components/InteractiveCanvas.astro';
import Heading1Card from '../components/Heading1Card.astro';
import NavBar from '../components/NavBar.astro';
import TextCard from '../components/TextCard.astro';
import VideoFill from '../components/VideoFill.astro';
import FullscreenLayout from '../layouts/FullscreenLayout.astro';
import PassiveOverlay from '../layouts/PassiveOverlay.astro';
import Layout from '../layouts/Layout.astro';

const title = "Willi Geiger";
const videoBg = { src: "/images/looping-smoke.mp4", type: "video/mp4" };
const heading = "Where are you?";
const text = "\
	Probably lost, I'm afraid.\
	I'm Willi Geiger, this is my place to experiment.\
	Right now, you're looking at a particle system.\
	Try interacting with the screen.";
---

<Layout title={title}>
	<main>
		<FullscreenLayout>
			<NavBar></NavBar>
		    <VideoFill
		      	src={videoBg.src}
				type=
			></VideoFill>
		    <PassiveOverlay>
				<Heading1Card text={heading}></Heading1Card>
				<TextCard text={text}></TextCard>
			</PassiveOverlay>
		    <InteractiveCanvas id="canvas"></InteractiveCanvas>
		</FullscreenLayout>
	</main>
</Layout>

<style>
	main {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		width: 100%;
		height: 100%;
		color: white;
		font-size: 20px;
		line-height: 1.6;
	}
</style>

<script>
	import { Point, ParticleSystem } from "../scripts/ParticleSystem";

	//const canvas = document.querySelector('.interactive-canvas') as HTMLCanvasElement;

	const canvas = document.getElementById("canvas") as HTMLCanvasElement;
	var tNow = performance.now();
	var tPre = tNow;
	requestAnimationFrame(animate);
	var mxPrev = 0, myPrev = 0;
	var mouseActive = false;

	function rotate(pos: Point, angle: number): Point {
		return new Point(
			Math.cos(angle) * pos.x + Math.sin(angle) * pos.y,
		   -Math.sin(angle) * pos.x + Math.cos(angle) * pos.y);
	}

	var bubbles: ParticleSystem = new ParticleSystem();
	bubbles.createGrid(50, 50);

	// Designate some of the particles as "spinners," which add velocity
	const numSpinners = 3;
	var spinners: number[] = [];
	var spinnerOmegas: number[] = [];
	for (var n = 0; n < numSpinners; n++) {
		const b = Math.round((bubbles.pos.length - 1) * Math.random());
		spinners.push(b);
		spinnerOmegas.push(2.25 * (Math.random() - 0.5));
	}

	function hsv2rgb(h: number, s: number, v: number): number[] {
		while (h < 0) {
			h += 1;
		}
		h *= 6;
		const i = Math.floor(h);
  		const f = h - i;
  		const p = v * (1 - s);
  		const q = v * (1 - f * s);
  		const t = v * (1 - (1 - f) * s);

	  switch (i % 6) {
	    case 0: return [v * 255, t * 255, p * 255];
	    case 1: return [q * 255, v * 255, p * 255];
	    case 2: return [p * 255, v * 255, t * 255];
	    case 3: return [p * 255, q * 255, v * 255];
	    case 4: return [t * 255, p * 255, v * 255];
	    case 5: return [v * 255, p * 255, q * 255];
	  }
	}

	function smoothstep(x0, x1, x) {
		let t = Math.min(1, Math.max(0, (x - x0) / (x1 - x0)));
  		return t * t * (3 - 2 * t);
	}

	// Explode on touch/button down
	canvas.addEventListener("mousedown", mousedown);
	//canvas.addEventListener("touchstart", touchstart);

	function mousedown(e: MouseEvent) {
		explode(e.clientX / canvas.clientWidth,
			    e.clientY / canvas.clientHeight, 200);
	}

	function touchstart(e: TouchEvent) {
		if (!e.touches[0]) {
			return;
		}
		explode(e.touches[0].clientX / canvas.clientWidth,
			    e.touches[0].clientY / canvas.clientHeight, 10);
	}

	function explode(x: number, y: number, force: number) {
		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		const sqrtArea = Math.sqrt(w * w + h * h);

		for (var i = 0; i < bubbles.pos.length; i++) {
			const dx = w * (bubbles.pos[i].x - x);
			const dy = h * (bubbles.pos[i].y - y);
			const d = Math.sqrt(dx * dx + dy * dy);
			if (d > 1) {
				const f = force * smoothstep(0.5, 0, (d / sqrtArea)) / d;
				bubbles.vel[i].x +=  f * dx / w;
				bubbles.vel[i].y +=  f * dy / h;
			}
		}
	}

	function animate() {
		tNow = performance.now();
		const dt = Math.min((tNow - tPre)/1000.0, 0.2);
		tPre = tNow;

		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		//const diag = Math.sqrt(w * w + h * h);
		canvas.width = w;
		canvas.height = h;

		const c = canvas.getContext('2d');
		//c.strokeStyle = "#fff4";
		//c.fillStyle = "#0001";
		c.strokeStyle = "#0004";
		c.fillStyle = "#0001";
		c.lineWidth = 0.5;

		// Mouse/touch velocity
		let mx = Number.parseFloat(canvas.getAttribute("cursorX"));
		let my = Number.parseFloat(canvas.getAttribute("cursorY"));
		//let vx = Number.parseFloat(canvas.getAttribute("cursorVX")) / w;
		//let vy = Number.parseFloat(canvas.getAttribute("cursorVY")) / h;
		let vx = mouseActive ? (mx - mxPrev) / w / dt : 0.0;
		let vy = mouseActive ? (my - myPrev) / h / dt : 0.0;
		mxPrev = mx;
		myPrev = my;
		mouseActive =
			(Number.parseInt(canvas.getAttribute("cursorActive")) != 0);

		for (var i = 0; i < bubbles.pos.length; i++) {
			bubbles.acc[i].x = 0.0;
			bubbles.acc[i].y = 0.0;

			// Mouse drag
			var dx = mx / w - bubbles.pos[i].x;
			var dy = my / h - bubbles.pos[i].y;
			if (dx >  0.5) dx -= 1.0;
			if (dx < -0.5) dx += 1.0;
			const Cd = 1.0;
			const falloff = 5.0;
			const d = Math.sqrt(dx * dx + dy * dy);
			const k = Math.pow(1.0 - Cd / (falloff * d + 1.0), dt);
			if (Math.abs(vx) > 0.0) {
				bubbles.acc[i].x += (1.0 - k) * (vx - bubbles.vel[i].x);
			}
			if (Math.abs(vy) > 0.0) {
				bubbles.acc[i].y += (1.0 - k) * (vy - bubbles.vel[i].y);
			}

			// Velocity from spinners
			var spinX = 0.0, spinY = 0.0;
			for (var n = 0; n < numSpinners; n++) {
				const dx = bubbles.pos[i].x - bubbles.pos[spinners[n]].x;
				const dy = bubbles.pos[i].y - bubbles.pos[spinners[n]].y;
				const d = Math.sqrt(dx * dx + dy * dy);
				const pRot = rotate(new Point(dx, dy),
				                    spinnerOmegas[n] / (2.0 * Math.PI));
				spinX += (pRot.x - dx) / Math.max(d, 0.001);
				spinY += (pRot.y - dy) / Math.max(d, 0.001);
			}

			// Fluid motion
			const upwardSpeed = -0.15;
			const waveMag = 0.017;
			const waveFreq = 8.0;
			const fluidDrag = 0.35;
			const df = Math.pow(1.0 - fluidDrag, dt);
			const fluidX = spinX +
				waveMag * (Math.cos(waveFreq * bubbles.pos[i].y) - 1.0);
			const fluidY = upwardSpeed + spinY;
			bubbles.acc[i].x += (1.0 - df) * (fluidX - bubbles.vel[i].x);
			bubbles.acc[i].y += (1.0 - df) * (fluidY - bubbles.vel[i].y);

			const brownianX = 0.35;
			const brownianY = 0.7;
			bubbles.acc[i].x += brownianX * dt * (Math.random() - 0.5);
			bubbles.acc[i].y += brownianY * dt * (Math.random() - 0.5);

			// Advect
			bubbles.vel[i].x += bubbles.acc[i].x;
			bubbles.vel[i].y += bubbles.acc[i].y;
			bubbles.pos[i].x += dt * bubbles.vel[i].x;
			bubbles.pos[i].y += dt * bubbles.vel[i].y;

			// Handle particles going off screen
			while (bubbles.pos[i].x < 0.0) {
				bubbles.pos[i].x += 1.0;
			}
			while (bubbles.pos[i].x > 1.0) {
				bubbles.pos[i].x -= 1.0;
			}
			while (bubbles.pos[i].y < 0.0) {
				bubbles.pos[i].y += 1.0;
			}
			if (bubbles.pos[i].y > 1.03) {
				bubbles.vel[i].y = -0.5 * Math.abs(bubbles.vel[i].y);
			}

			// Draw
			const areaScale = 0.001 * Math.sqrt(w * w + h * h);
			const px = bubbles.pos[i].x * w;
			const py = bubbles.pos[i].y * h;
			const hx = bubbles.vel[i].x;
			const hy = bubbles.vel[i].y - upwardSpeed;
			const hue = Math.atan2(hy, hx) / (2 * Math.PI) + 0.5;
			const sat = Math.min(0.2 * Math.pow(hx * hx + hy * hy, 0.0), 1.0);
			const val = 1.0;
			const rgb = hsv2rgb(hue, sat, val);
			const a = 0.75;
			const fillDarker = 0.4;
			c.strokeStyle = "rgba(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] +
			                    ", " + a + ")";
			c.fillStyle = "rgba(" + fillDarker * rgb[0] + ", " + fillDarker * rgb[1] +
								", " + fillDarker * rgb[2] + ", " + 0.2 + ")";
			c.beginPath();
			c.moveTo(px + areaScale * bubbles.rad[i], py);
			c.arc(px, py, areaScale * bubbles.rad[i], 0, 2.0 * Math.PI, false);
			c.stroke();
			c.fill();
		}

		requestAnimationFrame(animate);
	}
</script>

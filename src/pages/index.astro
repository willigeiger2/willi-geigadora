---
import InteractiveCanvas from '../components/InteractiveCanvas.astro';
import Heading1Card from '../components/Heading1Card.astro';
import NavBar from '../components/NavBar.astro';
import TextCard from '../components/TextCard.astro';
import VideoFill from '../components/VideoFill.astro';
import FullscreenLayout from '../layouts/FullscreenLayout.astro';
import PassiveOverlay from '../layouts/PassiveOverlay.astro';
import Layout from '../layouts/Layout.astro';

const title = "Willi Geiger";
const videoBg = { src: "/images/looping-smoke.mp4", type: "video/mp4" };
const heading = "Lost?";
const text = "\
	I'm Willi Geiger, this is my place to experiment.\
	Right now, you're looking at a particle system.\
	Try interacting with the screen.";
---

<Layout title={title}>
	<main>
		<FullscreenLayout>
			<NavBar></NavBar>
		    <VideoFill
		      	src={videoBg.src}
				type={videoBg.type}
			></VideoFill>
			<PassiveOverlay>
				<Heading1Card text={heading}></Heading1Card>
				<TextCard text={text}></TextCard>
			</PassiveOverlay>
		    <InteractiveCanvas id="canvas"></InteractiveCanvas>
		</FullscreenLayout>
	</main>
</Layout>

<style>
	main {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		width: 100%;
		height: 100%;
		color: white;
		font-size: 20px;
		line-height: 1.6;
	}
</style>

<script>
	import { BrownianField } from "../scripts/BrownianField";
	import { ConstantFalloff } from "../scripts/ConstantFalloff";
	import { LinearField } from "../scripts/LinearField";
	import { Color, Point, FieldOutput, ParticleSystem }
		from "../scripts/ParticleSystem";
	import { RadialFalloff } from "../scripts/RadialFalloff";
	import { RadialField } from "../scripts/RadialField";
	import { SumField } from "../scripts/SumField";
	import * as Utils from "../scripts/utils";
	import { VortexField } from "../scripts/VortexField";
	import { WaveField } from "../scripts/WaveField";

	const canvas = document.querySelector(
		'.interactive-canvas') as HTMLCanvasElement;
	let tPre = performance.now();
	var cxPrev = 0, cyPrev = 0;
	var cursorActive = false;

	let bubbles = new ParticleSystem();
	bubbles.createGrid(50, 50);

	// Designate some of the particles as "spinners," which add velocity
	const numSpinners = 3;
	var spinners: number[] = [];
	var spinnerOmegas: number[] = [];
	for (var n = 0; n < numSpinners; n++) {
		const b = Math.round((bubbles.pos.length - 1) * Math.random());
		spinners.push(b);
		spinnerOmegas.push(2.25 * (Math.random() - 0.5));
	}

	// Explode on touch/button down
	canvas.addEventListener("mousedown", mousedown);
	//canvas.addEventListener("touchstart", touchstart);

	function mousedown(e: MouseEvent) {
		explode(e.clientX / canvas.clientWidth,
			    e.clientY / canvas.clientHeight, 200);
	}

	/*
	function touchstart(e: TouchEvent) {
		if (!e.touches[0]) {
			return;
		}
		explode(e.touches[0].clientX / canvas.clientWidth,
			    e.touches[0].clientY / canvas.clientHeight, 10);
	}
	*/

	function explode(x: number, y: number, force: number) {
		let radialField = new RadialField(
			new Point(x, y),
			force,
			new Point(canvas.clientWidth, canvas.clientHeight));
		let radial = radialField.evaluate(bubbles.pos);

		for (var i = 0; i < bubbles.pos.length; i++) {
			// Don't factor in dt -- consider this an impulse force
			bubbles.vel[i].x += radial.falloff[i] * radial.field[i].x;
			bubbles.vel[i].y += radial.falloff[i] * radial.field[i].y;
		}
	}

	const brownianMagnitude = 0.005;
	let brownianField = new BrownianField(
		new Point(brownianMagnitude, brownianMagnitude));

	const upwardSpeed = -0.15;
	let upwardField = new LinearField(new Point(0.0, upwardSpeed));

	let cursorField = new LinearField(new Point(0.0, 0.0));
	const innerRadius = -0.1;
	const outerRadius = 0.5;
	let cursorFalloff = new RadialFalloff(
		new Point(0.0, 0.0),
		innerRadius, outerRadius, new Point(0.0, 0.0));

	bubbles.addPreAnimationCallback(preAnimation);
	bubbles.addPostAnimationCallback(postAnimation);
	bubbles.animate();

	function preAnimation(timestamp: number) {
		const dt = Math.min((timestamp - tPre)/1000.0, 1.0/15.0);
		tPre = timestamp;

		//console.log("FPS: " + 1.0 / dt);

		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		canvas.width = w;
		canvas.height = h;

		// Apply mouse drag
		let cx = Number.parseFloat(
			canvas.getAttribute("cursorX") || "0");
		let cy = Number.parseFloat(
			canvas.getAttribute("cursorY") || "0");
		let vx = cursorActive ? (cx - cxPrev) / w / dt : 0.0;
		let vy = cursorActive ? (cy - cyPrev) / h / dt : 0.0;
		cxPrev = cx;
		cyPrev = cy;
		cursorActive = (Number.parseInt(canvas.getAttribute(
			"cursorActive") || "0") != 0);
		cursorField.setDirection(new Point(vx, vy));
		let cursor = cursorField.evaluate(bubbles.pos);
		cursorFalloff.setCenter(new Point(cx / w, cy / h));
		cursorFalloff.setScreenSize(new Point(w, h));
		let falloff = cursorFalloff.evaluate(bubbles.pos);
		if (vx * vx + vy * vy > 0) {
			for (var i = 0; i < bubbles.pos.length; i++) {
				let cd = Math.pow(1.0 - Math.pow(falloff[i], 1.0), dt);
				bubbles.acc[i].x +=
					(1.0 - cd) * (cursor.field[i].x - bubbles.vel[i].x) / dt;
				bubbles.acc[i].y +=
					(1.0 - cd) * (cursor.field[i].y - bubbles.vel[i].y) / dt;
			}
		}

		let fluidField = new SumField([]);
		const fluidDrag = 0.35;
		let fluidFalloff = new ConstantFalloff(fluidDrag);

		// Spinners
		for (var n = 0; n < numSpinners; n++) {
			fluidField.addField(new VortexField(
					bubbles.pos[spinners[n]],
					spinnerOmegas[n]));
		}

		// Upward motion
		fluidField.addField(upwardField);

		// Horizontal oscillation
		const waveMag = 0.1;
		const waveFreq = 1.25;
		let waveAxis = new Point(0.0, 1.0);
		let waveField = new WaveField(waveAxis, waveMag, waveFreq, 0.0);
		fluidField.addField(waveField);

		// Combined fluid field
		let fluid = fluidField.evaluate(bubbles.pos);
		let fluidStrength = fluidFalloff.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			let fd = 1.0 - Math.pow(1.0 - fluidStrength[i], dt);
			bubbles.acc[i].x +=
			  fd * (fluid.field[i].x - bubbles.vel[i].x) / dt;
			bubbles.acc[i].y +=
			  fd * (fluid.field[i].y - bubbles.vel[i].y) / dt;
		}

		// Apply force fields
		let brownian = brownianField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			// Don't factor in dt -- consider this an impulse force
			bubbles.vel[i].x += brownian.falloff[i] * brownian.field[i].x;
			bubbles.vel[i].y += brownian.falloff[i] * brownian.field[i].y;
		}
	}

	function postAnimation(timestamp: number) {
		// Handle edges
		for (var i = 0; i < bubbles.pos.length; i++) {
			// Handle particles going off screen
			while (bubbles.pos[i].x < 0.0) {
				bubbles.pos[i].x += 1.0;
			}
			while (bubbles.pos[i].x > 1.0) {
				bubbles.pos[i].x -= 1.0;
			}
			while (bubbles.pos[i].y < 0.0) {
				bubbles.pos[i].y += 1.0;
			}
			if (bubbles.pos[i].y > 1.03) {
				bubbles.vel[i].y = -0.5 * Math.abs(bubbles.vel[i].y);
			}
		}

		// Set color according to relative velocity
		for (var i = 0; i < bubbles.pos.length; i++) {
			let hx = bubbles.vel[i].x;
			let hy = bubbles.vel[i].y - upwardSpeed;
			let hue = Math.atan2(hy, hx) / (2 * Math.PI) + 0.5;
			let sat = Math.min(0.2 * Math.pow(hx * hx + hy * hy, 0.0), 1.0);
			let val = 1.0;
			let rgb = Utils.hsv2rgb(hue, sat, val);
			let a = 0.75;
			bubbles.rgb[i] = new Color(rgb[0], rgb[1], rgb[2]);
			bubbles.alpha[i] = 0.8;
		}

		// Draw
		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		const areaScale = 0.001 * Math.sqrt(w * w + h * h);
		const fillDarker = 0.4;
		const fillTrans = 0.25;

		const c = canvas.getContext('2d');
		if (c == null) {
			return;
		}
		c.strokeStyle = "#0004";
		c.fillStyle = "#0001";
		c.lineWidth = 0.5;

		for (var i = 0; i < bubbles.pos.length; i++) {
			let px = bubbles.pos[i].x * w;
			let py = bubbles.pos[i].y * h;
			let rgb = bubbles.rgb[i];
			let alpha = bubbles.alpha[i];

			c.strokeStyle = "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b +
			                    ", " + alpha + ")";
			c.fillStyle = "rgba(" + fillDarker * rgb.r + ", " + fillDarker * rgb.g +
								", " + fillDarker * rgb.b + ", " + fillTrans * alpha + ")";
			c.beginPath();
			c.moveTo(px + areaScale * bubbles.rad[i], py);
			c.arc(px, py, areaScale * bubbles.rad[i], 0, 2.0 * Math.PI, false);
			c.stroke();
			c.fill();
		}
	}
</script>

---
import InteractiveCanvas from '../components/InteractiveCanvas.astro';
import Heading1Card from '../components/Heading1Card.astro';
import NavBar from '../components/NavBar.astro';
import TextCard from '../components/TextCard.astro';
import VideoFill from '../components/VideoFill.astro';
import FullscreenLayout from '../layouts/FullscreenLayout.astro';
import PassiveOverlay from '../layouts/PassiveOverlay.astro';
import Layout from '../layouts/Layout.astro';

const title = "Willi Geiger";
const videoBg = { src: "/images/looping-smoke.mp4", type: "video/mp4" };
const heading = "";
const text = "\
	I'm Willi Geiger, this is my place to experiment.\
	Right now, you're looking at a particle system.\
	Try interacting with the screen.";
---

<Layout title={title}>
	<main>
		<FullscreenLayout>
			<NavBar></NavBar>
		    <VideoFill
		      	src={videoBg.src}
				type=
			></VideoFill>
			<PassiveOverlay>
				<Heading1Card text={heading}></Heading1Card>
				<TextCard text={text}></TextCard>
			</PassiveOverlay>
		    <InteractiveCanvas id="canvas"></InteractiveCanvas>
		</FullscreenLayout>
	</main>
</Layout>

<style>
	main {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		width: 100%;
		height: 100%;
		color: white;
		font-size: 20px;
		line-height: 1.6;
	}
</style>

<script>
	import { BrownianField } from "../scripts/BrownianField";
	import { LinearField } from "../scripts/LinearField";
	import { Color, Point, FieldOutput, ParticleSystem } from "../scripts/ParticleSystem";
	import * as Utils from "../scripts/utils";

	const canvas = document.querySelector('.interactive-canvas') as HTMLCanvasElement;
	let tPre = performance.now();
	var cxPrev = 0, cyPrev = 0;
	var cursorActive = false;

	let bubbles = new ParticleSystem();
	bubbles.createGrid(50, 50);

	// Designate some of the particles as "spinners," which add velocity
	const numSpinners = 3;
	var spinners: number[] = [];
	var spinnerOmegas: number[] = [];
	for (var n = 0; n < numSpinners; n++) {
		const b = Math.round((bubbles.pos.length - 1) * Math.random());
		spinners.push(b);
		spinnerOmegas.push(2.25 * (Math.random() - 0.5));
	}

	// Explode on touch/button down
	canvas.addEventListener("mousedown", mousedown);
	//canvas.addEventListener("touchstart", touchstart);

	requestAnimationFrame(animate);

	function mousedown(e: MouseEvent) {
		explode(e.clientX / canvas.clientWidth,
			    e.clientY / canvas.clientHeight, 200);
	}

	function touchstart(e: TouchEvent) {
		if (!e.touches[0]) {
			return;
		}
		explode(e.touches[0].clientX / canvas.clientWidth,
			    e.touches[0].clientY / canvas.clientHeight, 10);
	}

	function explode(x: number, y: number, force: number) {
		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		const sqrtArea = Math.sqrt(w * w + h * h);

		for (var i = 0; i < bubbles.pos.length; i++) {
			const dx = w * (bubbles.pos[i].x - x);
			const dy = h * (bubbles.pos[i].y - y);
			const d = Math.sqrt(dx * dx + dy * dy);
			if (d > 1) {
				const f = force * Utils.smoothstep(0.5, 0, (d / sqrtArea)) / d;
				bubbles.vel[i].x +=  f * dx / w;
				bubbles.vel[i].y +=  f * dy / h;
			}
		}
	}

	// Field constants
	const upwardSpeed = -0.15;
	const waveMag = 0.017;
	const waveFreq = 8.0;
	const fluidDrag = 0.35;

	let brownianField = new BrownianField(new Point(25, 50));
	let upwardField = new LinearField(new Point(0.0, upwardSpeed));

	function animate(timestamp: number) {
		requestAnimationFrame(animate);
		const dt = Math.min((timestamp - tPre)/1000.0, 1.0/15.0);
		tPre = timestamp;

		//console.log("FPS: " + 1.0 / dt);

		const w = canvas.clientWidth;
		const h = canvas.clientHeight;
		canvas.width = w;
		canvas.height = h;

		const c = canvas.getContext('2d');
		if (c == null) {
			return;
		}
		c.strokeStyle = "#0004";
		c.fillStyle = "#0001";
		c.lineWidth = 0.5;

		// Reset acceleration
		for (var i = 0; i < bubbles.pos.length; i++) {
			bubbles.acc[i].x = 0.0;
			bubbles.acc[i].y = 0.0;
		}

		// Apply force fields
		let brownian = brownianField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			bubbles.acc[i].x += dt * brownian.falloff[i] * brownian.field[i].x;
			bubbles.acc[i].y += dt * brownian.falloff[i] * brownian.field[i].y;
		}

		// Apply mouse drag
		let cx = Number.parseFloat(
			canvas.getAttribute("cursorX") || "0");
		let cy = Number.parseFloat(
			canvas.getAttribute("cursorY") || "0");
		let vx = cursorActive ? (cx - cxPrev) / w / dt : 0.0;
		let vy = cursorActive ? (cy - cyPrev) / h / dt : 0.0;
		cxPrev = cx;
		cyPrev = cy;
		cursorActive = (Number.parseInt(canvas.getAttribute(
			"cursorActive") || "0") != 0);
		const Cd = 1.0;
		const falloff = 5.0;
		for (var i = 0; i < bubbles.pos.length; i++) {
			let dx = cx / w - bubbles.pos[i].x;
			let dy = cy / h - bubbles.pos[i].y;
			if (dx >  0.5) dx -= 1.0;
			if (dx < -0.5) dx += 1.0;
			const d = Math.sqrt(dx * dx + dy * dy);
			const k = Math.pow(1.0 - Cd / (falloff * d + 1.0), dt);
			if (Math.abs(vx) > 0.0) {
				bubbles.acc[i].x += (1.0 - k) * (vx - bubbles.vel[i].x) / dt;
			}
			if (Math.abs(vy) > 0.0) {
				bubbles.acc[i].y += (1.0 - k) * (vy - bubbles.vel[i].y) / dt;
			}
		}

		// Fluid drag
		let fluidVel = new Array<Point>(bubbles.pos.length);
		for (var i = 0; i < bubbles.pos.length; i++) {
			fluidVel[i] = new Point(0.0, 0.0);
		}

		// Spinners
		for (var n = 0; n < numSpinners; n++) {
			for (var i = 0; i < bubbles.pos.length; i++) {
				let dx = bubbles.pos[i].x - bubbles.pos[spinners[n]].x;
				let dy = bubbles.pos[i].y - bubbles.pos[spinners[n]].y;
				let d = Math.sqrt(dx * dx + dy * dy);
				let pRot = Utils.rotate(new Point(dx, dy),
				                  spinnerOmegas[n] / (2.0 * Math.PI));
				fluidVel[i].x += (pRot.x - dx) / Math.max(d, 0.001);
				fluidVel[i].y += (pRot.y - dy) / Math.max(d, 0.001);
			}
		}

		// Upward motion
		let upward = upwardField.evaluate(bubbles.pos);
		for (var i = 0; i < bubbles.pos.length; i++) {
			fluidVel[i].x += upward.falloff[i] * upward.field[i].x;
			fluidVel[i].y += upward.falloff[i] * upward.field[i].y;
		}

		// Horizontal oscillation
		for (var i = 0; i < bubbles.pos.length; i++) {
			fluidVel[i].x += waveMag *
				(Math.cos(waveFreq * bubbles.pos[i].y) - 1.0);
		}

		// Apply combined fluid drag
		let fd = Math.pow(1.0 - fluidDrag, dt);
		for (var i = 0; i < bubbles.pos.length; i++) {
			bubbles.acc[i].x += (1.0 - fd) * (fluidVel[i].x - bubbles.vel[i].x) / dt;
			bubbles.acc[i].y += (1.0 - fd) * (fluidVel[i].y - bubbles.vel[i].y) / dt;
		}

		bubbles.advect(dt);

		// Handle edges
		for (var i = 0; i < bubbles.pos.length; i++) {
			// Handle particles going off screen
			while (bubbles.pos[i].x < 0.0) {
				bubbles.pos[i].x += 1.0;
			}
			while (bubbles.pos[i].x > 1.0) {
				bubbles.pos[i].x -= 1.0;
			}
			while (bubbles.pos[i].y < 0.0) {
				bubbles.pos[i].y += 1.0;
			}
			if (bubbles.pos[i].y > 1.03) {
				bubbles.vel[i].y = -0.5 * Math.abs(bubbles.vel[i].y);
			}
		}

		// Set color according to relative velocity
		for (var i = 0; i < bubbles.pos.length; i++) {
			let hx = bubbles.vel[i].x;
			let hy = bubbles.vel[i].y - upwardSpeed;
			let hue = Math.atan2(hy, hx) / (2 * Math.PI) + 0.5;
			let sat = Math.min(0.2 * Math.pow(hx * hx + hy * hy, 0.0), 1.0);
			let val = 1.0;
			let rgb = Utils.hsv2rgb(hue, sat, val);
			let a = 0.75;
			bubbles.rgb[i] = new Color(rgb[0], rgb[1], rgb[2]);
			bubbles.alpha[i] = 0.8;
		}

		// Draw
		const areaScale = 0.001 * Math.sqrt(w * w + h * h);
		const fillDarker = 0.4;
		const fillTrans = 0.25;
		for (var i = 0; i < bubbles.pos.length; i++) {
			let px = bubbles.pos[i].x * w;
			let py = bubbles.pos[i].y * h;
			let rgb = bubbles.rgb[i];
			let alpha = bubbles.alpha[i];

			c.strokeStyle = "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b +
			                    ", " + alpha + ")";
			c.fillStyle = "rgba(" + fillDarker * rgb.r + ", " + fillDarker * rgb.g +
								", " + fillDarker * rgb.b + ", " + fillTrans * alpha + ")";
			c.beginPath();
			c.moveTo(px + areaScale * bubbles.rad[i], py);
			c.arc(px, py, areaScale * bubbles.rad[i], 0, 2.0 * Math.PI, false);
			c.stroke();
			c.fill();
		}
	}
</script>
